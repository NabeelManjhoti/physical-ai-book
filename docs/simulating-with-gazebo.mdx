---
sidebar_position: 4
title: "Simulating with Gazebo (World creation, Physics)"
---

# Simulating with Gazebo (World creation, Physics)

## Gazebo Simulation Environment

Gazebo is a powerful robotics simulation environment that provides high-fidelity physics simulation, realistic rendering, and convenient programmatic interfaces. It is widely used in robotics research and development for testing algorithms, robot design, and control strategies before deployment on real hardware.

### Key Features

- **High-fidelity Physics**: Accurate simulation of rigid body dynamics, collisions, and contact forces
- **Realistic Rendering**: High-quality graphics rendering with support for various sensors
- **Sensor Simulation**: Cameras, lidars, IMUs, GPS, and other sensors
- **Plugin Architecture**: Extensible system for custom models, controllers, and sensors
- **ROS Integration**: Seamless integration with ROS and ROS 2 through Gazebo ROS packages

### Installation and Setup

```bash
# Install Gazebo (Fortress for ROS 2 Humble)
sudo apt install ros-humble-gazebo-ros-pkgs

# Verify installation
gz sim --version
```

## World Creation and Customization

### Basic World Structure

Gazebo worlds are defined using SDF (Simulation Description Format) files, which are XML-based descriptions of the simulation environment.

```xml
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="default">
    <!-- Include models from Fuel or specify inline -->
    <include>
      <uri>model://ground_plane</uri>
    </include>

    <include>
      <uri>model://sun</uri>
    </include>

    <!-- Define custom models inline -->
    <model name="box">
      <pose>0 0 0.5 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>1 1 1</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>1 1 1</size>
            </box>
          </geometry>
        </visual>
      </link>
    </model>
  </world>
</sdf>
```

### Creating Custom Worlds

To create a custom world, create a `.sdf` or `.world` file:

```xml
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="my_custom_world">
    <physics type="ode">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1</real_time_factor>
      <real_time_update_rate>1000</real_time_update_rate>
    </physics>

    <light name="sun" type="directional">
      <cast_shadows>true</cast_shadows>
      <pose>0 0 10 0 0 0</pose>
      <diffuse>0.8 0.8 0.8 1</diffuse>
      <specular>0.2 0.2 0.2 1</specular>
      <attenuation>
        <range>1000</range>
        <constant>0.9</constant>
        <linear>0.01</linear>
        <quadratic>0.001</quadratic>
      </attenuation>
      <direction>-0.6 0.4 -0.8</direction>
    </light>

    <model name="ground_plane">
      <static>true</static>
      <link name="link">
        <collision name="collision">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <material>
            <ambient>0.7 0.7 0.7 1</ambient>
            <diffuse>0.7 0.7 0.7 1</diffuse>
            <specular>0.0 0.0 0.0 1</specular>
          </material>
        </visual>
      </link>
    </model>
  </world>
</sdf>
```

### Running Custom Worlds

```bash
# Launch Gazebo with a custom world
gz sim -r my_custom_world.sdf

# Or with ROS 2 integration
ros2 launch gazebo_ros empty_world.launch.py world:=/path/to/my_world.sdf
```

## Physics Engine Configuration

### Physics Engines in Gazebo

Gazebo supports multiple physics engines:
- **ODE (Open Dynamics Engine)**: Default engine, good balance of speed and accuracy
- **Bullet**: Good for complex collision detection
- **DART**: Advanced physics simulation
- **Simbody**: Multi-body dynamics

### Physics Parameters

```xml
<physics type="ode">
  <!-- Time step settings -->
  <max_step_size>0.001</max_step_size>
  <real_time_factor>1</real_time_factor>
  <real_time_update_rate>1000</real_time_update_rate>

  <!-- Solver settings -->
  <ode>
    <solver>
      <type>quick</type>
      <iters>10</iters>
      <sor>1.3</sor>
    </solver>
    <constraints>
      <cfm>0.0</cfm>
      <erp>0.2</erp>
      <contact_max_correcting_vel>100</contact_max_correcting_vel>
      <contact_surface_layer>0.001</contact_surface_layer>
    </constraints>
  </ode>
</physics>
```

### Collision Detection Settings

```xml
<physics type="ode">
  <ode>
    <constraints>
      <!-- Contact surface layer - allows slight penetration for stability -->
      <contact_surface_layer>0.001</contact_surface_layer>
      <!-- Maximum correcting velocity for contacts -->
      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>
    </constraints>
  </ode>
</physics>
```

## Robot Model Integration

### Creating Robot Models

Robot models in Gazebo use URDF (Unified Robot Description Format) or SDF:

```xml
<?xml version="1.0"?>
<robot name="simple_robot">
  <link name="base_link">
    <visual>
      <geometry>
        <box size="0.5 0.5 0.2"/>
      </geometry>
    </visual>
    <collision>
      <geometry>
        <box size="0.5 0.5 0.2"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="1"/>
      <inertia ixx="0.083" ixy="0" ixz="0" iyy="0.083" iyz="0" izz="0.083"/>
    </inertial>
  </link>

  <joint name="base_to_wheel" type="continuous">
    <parent link="base_link"/>
    <child link="wheel_link"/>
    <axis xyz="0 1 0"/>
  </joint>

  <link name="wheel_link">
    <visual>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
    </visual>
    <collision>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="0.2"/>
      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>
    </inertial>
  </link>
</robot>
```

### Adding Gazebo-Specific Elements

To make URDF work properly in Gazebo, add Gazebo-specific elements:

```xml
<gazebo reference="base_link">
  <material>Gazebo/Green</material>
  <mu1>0.2</mu1>
  <mu2>0.2</mu2>
</gazebo>

<gazebo>
  <plugin name="diff_drive" filename="libgazebo_ros_diff_drive.so">
    <left_joint>left_wheel_joint</left_joint>
    <right_joint>right_wheel_joint</right_joint>
    <wheel_separation>0.4</wheel_separation>
    <wheel_diameter>0.2</wheel_diameter>
    <command_topic>cmd_vel</command_topic>
    <odometry_topic>odom</odometry_topic>
    <odometry_frame>odom</odometry_frame>
    <robot_base_frame>base_link</robot_base_frame>
  </plugin>
</gazebo>
```

## Simulation Workflows

### Basic Simulation Launch

```bash
# Launch empty world
ros2 launch gazebo_ros empty_world.launch.py

# Launch with a specific world
ros2 launch gazebo_ros empty_world.launch.py world:=my_world.sdf

# Launch with GUI
ros2 launch gazebo_ros gzserver.launch.py &
ros2 launch gazebo_ros gzclient.launch.py
```

### Spawning Models

```bash
# Spawn a model from command line
ros2 run gazebo_ros spawn_entity.py -entity my_robot -file /path/to/robot.urdf -x 0 -y 0 -z 1

# Spawn with namespace
ros2 run gazebo_ros spawn_entity.py -entity my_robot -file /path/to/robot.urdf -robot_namespace /my_robot
```

### Controlling Simulation

```bash
# Pause simulation
rosservice call /pause_physics "{}"

# Unpause simulation
rosservice call /unpause_physics "{}"

# Reset simulation
rosservice call /reset_simulation "{}"

# Reset world
rosservice call /reset_world "{}"
```

## Code Blocks for Gazebo Commands

### Launch Files for Gazebo Integration

```xml
<launch>
  <!-- Launch Gazebo with a world -->
  <include file="$(find-pkg-share gazebo_ros)/launch/gzserver.launch.py">
    <arg name="world" value="$(find-pkg-share my_robot_description)/worlds/my_world.sdf"/>
    <arg name="paused" value="true"/>
    <arg name="use_sim_time" value="true"/>
  </include>

  <include file="$(find-pkg-share gazebo_ros)/launch/gzclient.launch.py">
  </include>

  <!-- Spawn robot in Gazebo -->
  <node name="spawn_urdf" pkg="gazebo_ros" exec="spawn_entity.py"
        args="-entity my_robot -file $(find-pkg-share my_robot_description)/urdf/my_robot.urdf -x 0 -y 0 -z 0.5">
  </node>
</launch>
```

### ROS 2 Node for Gazebo Interaction

```python
import rclpy
from rclpy.node import Node
from gazebo_msgs.srv import SetEntityState
from gazebo_msgs.msg import EntityState
from geometry_msgs.msg import Twist

class GazeboController(Node):
    def __init__(self):
        super().__init__('gazebo_controller')

        # Service client for setting entity state
        self.set_state_client = self.create_client(
            SetEntityState, '/set_entity_state')

        # Publisher for velocity commands
        self.cmd_vel_pub = self.create_publisher(
            Twist, '/my_robot/cmd_vel', 10)

        while not self.set_state_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Service not available, waiting again...')

    def move_robot(self, x, y, z, roll, pitch, yaw):
        req = SetEntityState.Request()
        req.state.name = 'my_robot'
        req.state.pose.position.x = x
        req.state.pose.position.y = y
        req.state.pose.position.z = z
        req.state.pose.orientation = self.euler_to_quaternion(roll, pitch, yaw)

        future = self.set_state_client.call_async(req)
        return future

def main(args=None):
    rclpy.init(args=args)
    controller = GazeboController()

    # Example: move robot to position (1, 1, 0.5)
    future = controller.move_robot(1.0, 1.0, 0.5, 0, 0, 0)

    rclpy.spin_until_future_complete(controller, future)
    controller.destroy_node()
    rclpy.shutdown()

def euler_to_quaternion(self, roll, pitch, yaw):
    # Convert Euler angles to quaternion
    import math
    cy = math.cos(yaw * 0.5)
    sy = math.sin(yaw * 0.5)
    cp = math.cos(pitch * 0.5)
    sp = math.sin(pitch * 0.5)
    cr = math.cos(roll * 0.5)
    sr = math.sin(roll * 0.5)

    q = [0] * 4
    q[0] = cy * cp * cr + sy * sp * sr  # w
    q[1] = cy * cp * sr - sy * sp * cr  # x
    q[2] = sy * cp * sr + cy * sp * cr  # y
    q[3] = sy * cp * cr - cy * sp * sr  # z

    from geometry_msgs.msg import Quaternion
    quat_msg = Quaternion()
    quat_msg.w = q[0]
    quat_msg.x = q[1]
    quat_msg.y = q[2]
    quat_msg.z = q[3]
    return quat_msg
```

### Sensor Data Processing

```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan, Image
from cv_bridge import CvBridge
import numpy as np

class GazeboSensorProcessor(Node):
    def __init__(self):
        super().__init__('gazebo_sensor_processor')

        self.scan_sub = self.create_subscription(
            LaserScan, '/my_robot/laser_scan', self.scan_callback, 10)

        self.image_sub = self.create_subscription(
            Image, '/my_robot/camera/image_raw', self.image_callback, 10)

        self.cv_bridge = CvBridge()

    def scan_callback(self, msg):
        # Process laser scan data
        ranges = np.array(msg.ranges)
        # Filter out invalid ranges
        valid_ranges = ranges[np.isfinite(ranges)]

        if len(valid_ranges) > 0:
            min_distance = np.min(valid_ranges)
            self.get_logger().info(f'Minimum distance: {min_distance:.2f}m')

    def image_callback(self, msg):
        # Convert ROS Image message to OpenCV image
        cv_image = self.cv_bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')

        # Process image (example: detect edges)
        gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)
        edges = cv2.Canny(gray, 50, 150)

        # Do something with processed image
        # ...
```

## Best Practices

1. **Start Simple**: Begin with basic shapes and gradually add complexity
2. **Use Appropriate Physics Settings**: Balance accuracy with performance
3. **Validate Models**: Test URDF models in RViz before simulation
4. **Use Realistic Inertial Properties**: Accurate mass and inertia values improve simulation
5. **Consider Computational Load**: Complex scenes may require reduced physics accuracy
6. **Test in Simulation First**: Validate control algorithms in simulation before hardware
7. **Use Appropriate Scales**: Avoid very small or very large objects for stability
8. **Monitor Performance**: Keep an eye on real-time factor during simulation

## Troubleshooting Common Issues

- **Robot Falls Through Ground**: Check collision geometry and static property
- **Jittery Movement**: Adjust physics parameters (time step, solver iterations)
- **Models Not Spawning**: Verify URDF/SDF syntax and file paths
- **Sensor Data Issues**: Check topic names and frame IDs

## Summary

Gazebo provides a comprehensive simulation environment for robotics development. Understanding world creation, physics configuration, and robot model integration is essential for effective simulation workflows. Proper setup allows for realistic testing of algorithms before deployment on real hardware.